## 01 快速排序
TestQuickSort.java  

背景介绍：  
又称划分交换排序（partition-exchange sort），一种排序算法，最早由东尼·霍尔提出。
在平均状况下，排序n个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。
事实上，快速排序通常明显比其他Ο(n log n)算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来 —– 来自 wikipedia **

算法规则：  
本质来说，快速排序的过程就是不断地将无序元素集递归分割，一直到所有的分区只包含一个元素为止。
由于快速排序是一种分治算法，我们可以用分治思想将快排分为三个步骤：
1.分：设定一个分割值，并根据它将数据分为两部分
2.治：分别在两部分用递归的方式，继续使用快速排序法
3.合：对分割的部分排序直到完成

算法分析：  
平均时间复杂度O（nlogn），最坏时间复杂度O（n*n）,辅助空间O（logn）<每次都要分给一个额外空间，而总共有logn次>
每次分成两段，那么分的次数就是logn了，每一次处理需要n次计算，那么时间复杂度就是nlogn了！
根据平均情况来说是O(nlogn),因为在数据分布等概率的情况下对于单个数据来说在logn次移动后就会被放到正确的位置上了。
最坏是O(n^2).这种情况就是数组刚好的倒序，然后每次去中间元的时候都是取最大或者最小。

稳定性：不稳定。


## 02 归并排序
TestMergeSort.java  

简介：将两个（或两个以上）有序表合并成一个新的有序表 即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列
一趟归并需要将数组 a[]中相邻的长度为h的有序序列进行两两归并.并将结果放到temp[]中，这需要将待排序列中的所有记录扫描一遍，因此耗费O(n)，
而又完全二叉树的深度可知，整个归并排序需要进行logn次，因此总的时间复杂度为O(nlogn)，而且这是归并排序算法中最好、最坏、平均的时间性能。
由于归并排序在归并过程中需要与原始序列同样数量的存储空间存放归并结果以及递归时深度为logn的栈空间，因此空间复杂度为O(n+logn).
另外，对代码进行仔细研究，发现merge函数中有if (a[i] < a[j]) 的语句，说明它需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法。
也就是说，归并排序是一种比较占内存，但却效率高且稳定的算法。


## 综合分析
最差时间分析 平均时间复杂度 稳定度 空间复杂度  
冒泡排序	O(n2)	O(n2)	         稳定	O(1)  
快速排序	O(n2)	O(n*log2n)	    不稳定	O(log2n)~O(n)  
选择排序	O(n2)	O(n2)	         稳定	O(1)  
二叉树排序	O(n2)	O(n*log2n)	    不一定	O(n)  
插入排序    O(n2)	O(n2)	         稳定	O(1)  
堆排序	O(n*log2n)	O(n*log2n)	    不稳定	O(1)  
希尔排序	O	    O	            不稳定	O(1)  