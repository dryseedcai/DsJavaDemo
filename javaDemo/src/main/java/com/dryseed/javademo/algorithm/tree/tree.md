## 01 二叉树 先序、中序、后序遍历
OrderTree.java  
二叉树 先序、中序、后序遍历

## 02 二叉树 广度、深度优先遍历 
BinaryTreeTraversal.java  
二叉树 广度、深度优先遍历

## 03 判断该树是不是平衡二叉树
TestIsAvlTree.java  
平衡二叉树：如果某二叉树中任意结点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。
思路：我们用后序遍历的方式遍历二叉树的每一个结点，在遍历到一个结点之前我们已经遍历了它的左右子树。
只要在遍历每个结点的时候记录它的深度（某一结点的深度等于它到叶节点的路径的长度），我们就可以一边遍历一边判断每个结点是不是平衡的

## 04 反转二叉树
ReverseBinaryTree.java  
我们使用分治的思维，假如说我们有个函数，专门翻转二叉树的。
假如我们把B子树翻转好，再把C子树翻转好，那么我们要做的岂不就是简单的把A节点的左赋给C(原来是B)，再把A节点的右赋给B(原来是C)。

## 05 构建二叉排序树
BinarySortTree.java
二叉排序树（BinarySortTree），又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树
1.若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
2.若它的右子树不空，则右子树上所有结点的值均小于它的根结点的值；
3.它的左、右子树也分别为二叉排序树。

## 06.求二叉树的最大深度
BinaryTreeMaxDepth.java

## 07.求二叉树的最小深度
BinaryTreeMinDepth.java

## 08.求二叉树中叶子节点的个数
P08.java

## 09.求二叉树中第k层节点的个数
P09.java

## 10.两个二叉树是否完全相同
P10.java

## 11.在二叉排序树中插入节点
P11.java
问题描述：给定一棵二叉查找树和一个新的树节点，将节点插入到树中。你需要保证该树仍然是一棵二叉查找树。
思路：插入的节点与根节点比较大小，如果大于根节点，插入做根节点的右孩子；如果小于根节点，做根节点的左孩子，递归下去。

## 12.输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。 
SwordToOffer P143  
FindTreePath.java  
从树的根节点开始往下一直到叶结点所经过的所有的结点形成一条路径。




